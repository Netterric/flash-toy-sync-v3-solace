package models {
	
	import core.TPDisplayObject;
	import core.TPMovieClip;
	import flash.display.DisplayObjectContainer;
	import flash.display.MovieClip;
	import flash.display.Scene;
	import states.AnimationInfoStates;
	import states.EditorStates;
	import utils.HierarchyUtil;
	import utils.MathUtil;
	
	/**
	 * ...
	 * @author notSafeForDev
	 */
	public class SceneModel {
		
		/** Status for when nothing unusual happened during update */
		public static var UPDATE_STATUS_NORMAL : String = "UPDATE_STATUS_NORMAL";
		/** Status for when the scene was exited on it's own, such as when the user clicks a button and the animation changes frames */
		public static var UPDATE_STATUS_EXIT : String = "UPDATE_STATUS_EXIT";
		/** Status for when the scene looped from it's first frame */
		public static var UPDATE_STATUS_LOOP_START : String = "UPDATE_STATUS_LOOP_START";
		/** Status for when the scene looped from a frame after the first */
		public static var UPDATE_STATUS_LOOP_MIDDLE : String = "UPDATE_STATUS_LOOP_MIDDLE";
		
		public var isTemporary : Boolean = false;
		
		protected var path : Vector.<String> = null;
		
		protected var startFrames : Vector.<Number> = null;
		protected var endFrames : Vector.<Number> = null;
		protected var firstStopFrames : Vector.<Number> = null;
		
		private var lastPlayingFrames : Vector.<Number> = null;
		private var forceStoppedAtFrames : Vector.<Number> = null;
		
		private var isForceStopped : Boolean = false;
		
		private var script : SceneScriptModel = null;
		
		public function SceneModel(_path : Vector.<String>) {
			path = _path;
		}
		
		/**
		 * Create a new scene from save data
		 * @param	_saveData	The save data to use, generated by the toSaveData method
		 * @return 	The scene
		 */
		public static function fromSaveData(_saveData : Object) : SceneModel {
			var scene : SceneModel = new SceneModel(_saveData.path);
			
			scene.startFrames = _saveData.startFrames;
			scene.endFrames = _saveData.endFrames;
			scene.firstStopFrames = _saveData.firstStopFrames;
			
			return scene;
		}
		
		/**
		 * Get information about the scene as save data
		 * @return	The save data
		 */
		public function toSaveData() : Object {
			return {path: path, startFrames: startFrames, endFrames: endFrames, firstStopFrames: firstStopFrames}
		}
		
		public function merge(_otherScene : SceneModel) : void {
			if (path.join(",") != _otherScene.path.join(",")) {
				throw new Error("Unable to merge scenes, their paths are not the same");
			}
			
			for (var i : Number = 0; i < startFrames.length; i++) {
				startFrames[i] = Math.min(startFrames[i], _otherScene.startFrames[i]);
				endFrames[i] = Math.max(endFrames[i], _otherScene.endFrames[i]);
				firstStopFrames[i] = Math.max(firstStopFrames[i], _otherScene.firstStopFrames[i]);
			}
		}
		
		/**
		 * Get the start frames for each child that is part of the scene, starting from the top most, ending with the inner child
		 * @return	An array of frames
		 */
		public function getStartFrames() : Vector.<Number> {
			return startFrames.slice();
		}
		
		/**
		 * Get the end frames for each child that is part of the scene, starting from the top most, ending with the inner child
		 * @return	An array of frames
		 */
		public function getEndFrames() : Vector.<Number> {
			return endFrames.slice();
		}
		
		/**
		 * Get the total number of frames for the inner child only
		 * @return	The total number of frames
		 */
		public function getTotalInnerFrames() : Number {
			return endFrames[endFrames.length - 1] - startFrames[startFrames.length - 1] + 1;
		}
		
		/**
		 * Get the path to the children that are part of the scene
		 * @return
		 */
		public function getPath() : Vector.<String> {
			return path.slice();
		}
		
		/**
		 * Has to be called before calling the update method
		 */
		public function enter() : void {
			if (startFrames != null) {
				return;
			}
			
			startFrames = getCurrentFramesWhileActive();
			endFrames = getCurrentFramesWhileActive();
			
			firstStopFrames = new Vector.<Number>();
			
			for (var i : Number = 0; i < startFrames.length; i++) {
				firstStopFrames.push(-1);
			}
		}
		
		/**
		 * Has to be called when the scene is no longer selected
		 */
		public function exit() : void {
			if (isForceStopped == true && isActive() == true) {
				play();
			}
			
			isForceStopped = false;
			lastPlayingFrames = null;
			forceStoppedAtFrames = null;
		}
		
		/**
		 * Updates information about the scene. Must be called on every frame while the scene is selected to ensure that it's information is accurate
		 * @return A status code for what happened during the update
		 */
		public function update() : String {
			if (startFrames == null) {
				throw new Error("Unable to update scene, it have not been entered");
			}
			
			// If it's force stopped, but the scene somehow isn't active anymore, exit it
			if (isForceStopped == true && isActive() == false) {
				exit();
				return SceneModel.UPDATE_STATUS_EXIT;
			}
			
			// If it's force stopped, but something caused the frames to change, resume playing
			if (isForceStopped == true && isAtFramesWhileActive(forceStoppedAtFrames) == false) {
				play();
			}
			
			// If the scene wasn't resumed above, stop here
			if (isForceStopped == true) {
				return SceneModel.UPDATE_STATUS_NORMAL;
			}
			
			var i : Number;
			var currentFrames : Vector.<Number> = getCurrentFramesWhileActive();
			var didExitScene : Boolean = false;
			
			// Check if it's currently on a frame within the scene, if not, we want to exit it
			for (i = 0; i < currentFrames.length; i++) {				
				var isStopped : Boolean = currentFrames[i] == firstStopFrames[i];
				var expectedMinFrame : Number = startFrames[i];
				var expectedMaxFrame : Number = isStopped ? endFrames[i] : endFrames[i] + 1;
				
				if (currentFrames[i] < expectedMinFrame || currentFrames[i] > expectedMaxFrame) {
					didExitScene = true;
					break;
				}
			}
			
			// If it did exit it, we don't want to update anything about the scene and exit it
			if (didExitScene == true) {
				exit();
				return SceneModel.UPDATE_STATUS_EXIT;
			}
			
			// If we're in the editor, update first stop frames and end frames
			if (EditorStates.isEditor.value == true) {
				for (i = 0; i < currentFrames.length; i++) {
					if (lastPlayingFrames != null && currentFrames[i] == lastPlayingFrames[i] && firstStopFrames[i] < 0) {
						firstStopFrames[i] = currentFrames[i];
					}
					
					endFrames[i] = Math.max(endFrames[i], currentFrames[i]);
				}
			}
			
			// If the last playing frames aren't set, we stop here since we can't determine if it have looped or not
			if (lastPlayingFrames == null) {
				lastPlayingFrames = currentFrames;
				return SceneModel.UPDATE_STATUS_NORMAL;
			}
			
			var innerChildIndex : Number = currentFrames.length - 1;
			var innerChildCurrentFrame : Number = currentFrames[innerChildIndex];
			var innerChildLastFrame : Number = lastPlayingFrames[innerChildIndex];
			var innerChildStartFrame: Number = startFrames[innerChildIndex];
			
			var updateStatus : String = SceneModel.UPDATE_STATUS_NORMAL;
			
			// Check if the scene looped, and wether it did it from the start or not
			if (innerChildCurrentFrame < innerChildLastFrame) {
				if (innerChildCurrentFrame == innerChildStartFrame) {
					updateStatus = SceneModel.UPDATE_STATUS_LOOP_START;
				} else {
					updateStatus = SceneModel.UPDATE_STATUS_LOOP_MIDDLE;
				}
			}
			
			lastPlayingFrames = currentFrames;
			
			return updateStatus;
		}
		
		/**
		 * Check wether the animation is at the scene currently
		 * @return Wether it is at the scene
		 */
		public function isActive() : Boolean {
			var root : TPMovieClip = AnimationInfoStates.animationRoot.value;
			
			var children : Vector.<TPMovieClip> = HierarchyUtil.getMovieClipsFromPath(root, path);
			if (children == null) {
				return false;
			}
			
			for (var i : Number = 0; i < children.length; i++) {
				var currentFrame : Number = children[i].currentFrame;
				var startFrame : Number = startFrames[i];
				var endFrame : Number = endFrames[i];
				if (currentFrame < startFrame || currentFrame > endFrame) {
					return false;
				}
			}
			
			return true;
		}
		
		/**
		 * Play all the nested children that are part of the scene, except if a child is at a frame where it was naturally stopped as part of the animation
		 * Can only be called while the scene is active
		 */
		public function play() : void {
			var children : Vector.<TPMovieClip> = getChildrenWhileActive();
			
			for (var i : Number = 0; i < children.length; i++) {
				var child : TPMovieClip = children[i];
				var firstStopFrame : Number = firstStopFrames[i];
				
				if (child.currentFrame < firstStopFrame) {
					child.play();
				}
			}
			
			isForceStopped = false;
		}
		
		/**
		 * Stop all nested children that are part of the scene
		 * Can only be called while the scene is active
		 */
		public function stop() : void {
			var children : Vector.<TPMovieClip> = getChildrenWhileActive();
			
			for (var i : Number = 0; i < children.length; i++) {
				var child : TPMovieClip = children[i];
				child.stop();
			}
			
			setAsForceStopped();
		}
		
		/**
		 * Play from a specific frame within the scene
		 * @param _frames	The frame to use for each child that is apart of the scene, ending with the frame for the inner child
		 */
		public function gotoAndPlay(_frames : Vector.<Number>) : void {
			gotoFrame(_frames, true);
		}
		
		/**
		 * Stop at a specific frame within the scene
		 * @param _frames	The frame to use for each child that is apart of the scene, ending with the frame for the inner child
		 */
		public function gotoAndStop(_frames : Vector.<Number>) : void {
			gotoFrame(_frames, false);
		}
		
		/**
		 * Stops and steps frames for the inner child only
		 * Can only be called while the scene is active
		 * @param	_frames		The number of frames to step. If a negative value is used, it will step backwards
		 */
		public function stepFrames(_frames : Number) : void {
			stop();
			
			var children : Vector.<TPMovieClip> = getChildrenWhileActive();
			var lastChildIndex : Number = children.length - 1;
			
			var currentFrame : Number = children[lastChildIndex].currentFrame;
			var startFrame : Number = startFrames[lastChildIndex];
			var endFrame : Number = endFrames[lastChildIndex];
			var targetFrame : Number = MathUtil.clamp(currentFrame + _frames, startFrame, endFrame);
			
			children[lastChildIndex].gotoAndStop(targetFrame);
			
			setAsForceStopped();
		}
		
		private function gotoFrame(_frames : Vector.<Number>, _shouldPlay : Boolean) : void {
			var root : TPMovieClip = AnimationInfoStates.animationRoot.value;
			
			for (var i : Number = 0; i < _frames.length; i++) {
				var currentPath : Vector.<String> = path.slice(0, i);
				
				var children : Vector.<TPMovieClip> = HierarchyUtil.getMovieClipsFromPath(root, currentPath);
				var child : TPMovieClip = children[children.length - 1];
				var firstStopFrame : Number = firstStopFrames[i];
				var isStoppedAtFrame : Boolean = firstStopFrame >= 0 && _frames[i] >= firstStopFrame;
				
				if (_shouldPlay == true && isStoppedAtFrame == false) {
					child.gotoAndPlay(_frames[i]);
				} else {
					child.gotoAndStop(_frames[i]);
				}
			}
			
			if (_shouldPlay == false) {
				setAsForceStopped();
			} else {
				isForceStopped = false;
			}
		}
		
		private function setAsForceStopped() : void {
			isForceStopped = true;
			forceStoppedAtFrames = getCurrentFramesWhileActive();
			lastPlayingFrames = null;
		}
		
		private function getChildrenWhileActive() : Vector.<TPMovieClip> {
			var root : TPMovieClip = AnimationInfoStates.animationRoot.value;
			
			var children : Vector.<TPMovieClip> = HierarchyUtil.getMovieClipsFromPath(root, path);
			if (children == null) {
				throw new Error("Unable to get children, the scene is not active");
			}
			
			return children;
		}
		
		private function getCurrentFramesWhileActive() : Vector.<Number> {
			var children : Vector.<TPMovieClip> = getChildrenWhileActive();
			var frames : Vector.<Number> = new Vector.<Number>();
			
			for (var i : Number = 0; i < children.length; i++) {
				var child : TPMovieClip = children[i];
				frames.push(child.currentFrame);
			}
			
			return frames;
		}
		
		private function isAtFramesWhileActive(_frames : Vector.<Number>) : Boolean {
			var currentFrames : Vector.<Number> = getCurrentFramesWhileActive();
			
			for (var i : Number = 0; i < _frames.length; i++) {
				if (currentFrames[i] != currentFrames[i]) {
					return false;
				}
			}
			
			return true;
		}
	}
}